### 1. TCP/UDP

1. 三次握手与四次挥手

   两次SYN发送包含滑动窗口大小

   FIN_WAIT2为半关闭状态

   TIME_WAIT时无法建立该端口的连接，需要端口复用

   <img src="C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20200717160026161.png" alt="image-20200717160026161" style="zoom:67%;" />

   ![image-20200806155031536](C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20200806155031536.png)

2. 可靠性保证

   1. TCP：

      1. 序列号、确认序号、超时重传(2*RTT+偏差值)
         1. 保证了可靠性
         2. 保证数据按顺序到达
         3. 提高效率，实现多次发送
         4. 去除重复数据

      2. TCP校验和（UDP可选，首部+数据）

      3. 连接管理

      4. 流量控制：控制发送速度，不然可能导致发送方发送数据过快导致缓冲区满。滑动窗口控制

      5. 拥塞窗口：

         发送开始时定义拥塞窗口大小为1；每次收到一个ACK应答，拥塞窗口加1；而在每次发送数据时，发送窗口取拥塞窗口与接送段接收窗口最小者。（注意要和滑动窗口的上限）

         快恢复：收到三个失序的就认为阻塞，拥塞窗口取半，然后拥塞避免算法
         
      6. ![image-20200821102541661](C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20200821102541661.png)

      7. ![image-20200821102550936](C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20200821102550936.png)

   2. UDP：依赖于应用层实现

3. 数据包长度

   以太网帧1518字节，帧头尾18字节，IP头部20字节

   TCP包大小：1500-20（IP头）-20（TCP头） = 1460B

   UDP包大小：1500-20（IP头）-8(UDP头) = 1472B

4. TCP

   1. 滑动窗口：可以累计确认

      发送端会根据接收端的滑动窗口大小来调整一次性的发送数量，处理完毕、累计确认后回执包会改变滑动窗口大小

5. MSS：网络层最大传输但与1500

   MTU：最大报文长度1460

6. ![image-20200723230812164](C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20200723230812164.png)

7. TCP/UDP的对比

   1. TCP：面向连接的可靠数据流传输
      1. 完全弥补，丢失重传
      2. 传输速度慢、需要开销保持连接
      3. 任意两个数据包的路径相同
   2. UDP：无连接不可靠的数据包传输
      1. 不完全弥补：顺序不保证
      2. 传输速度快，开销小
      3. 时效性高，稳定性不要求
      4. 数据包传输路径不一定相同

8. TCP通信中存在错误

   1. 与不存在的端口建立连接，connect未建立连接的IP端口，触发服务端的RST分节
   2. 与不存在的主机进行连接，即SYN无响应，6s，24s，75s发送三个，再无返回设置ETIMEOUT，或者自己设置超时时间
   3. server进程被阻塞：例如：服务器硬盘满。连接可以正常建立，应答ACK，但是数据无法从内核缓冲区复制到进程缓冲区，无返回
   4. server被杀死：主动关闭时，SIGTERM会调用close关闭文件描述符
   5. server关机：Init首先发送SIGTERM，过段时间发送SIGKILL
   6. 主机宕机：使用心跳包保持连接

9. 使用2MSL可以保证ACK被接受，能够让双方都建立连接

   使用端口复用取消等待时间

10. TCP保证可靠性

    1. 序列号、确认应答、超时重传

       每个报文均带有序列号，到达接收方时，接收方需要进行确认应答，同时回复的确认序列号表明了下一次接受的数据序列号。如果迟迟未收到，那么有可能是发送数据、确认应答丢失，超过一定时间后进行重传（一般为2*RTT(报文段往返时间）+偏差值）

    2. 滑动窗口、快速重传

       使用窗口控制传输速度。在一个大小内不需要等待确认就可以继续发送数据。

       使用窗口控制，如果数据段1001-2000丢失，后面数据每次传输，确认应答都会不停地发送序号为1001的应答，表示我要接收1001开始的数据，发送端如果收到3次相同应答，就会立刻进行重发；但还有种情况有可能是数据都收到了，但是有的应答丢失了，这种情况不会进行重发

    3. 拥塞控制

       拥塞避免：当拥塞窗口达到阈值，不再指数上升，而是线性上升

       快重传：收到三个重复确认应答重传

11. 三次握手、四次挥手的原因

    1. 防止已经失效的连接再次传入服务器导致资源浪费

       客户端先发送了一个SYN，但是由于网络阻塞，该SYN数据包在某个节点长期滞留。然后客户端又重传SYN数据包并正确建立TCP连接，然后传输完数据后关闭该连接。该连接释放后失效的SYN数据包才到达服务器端。在二次握手的前提下，服务器端会认为这是客户端发起的又一次请求，然后发送SYN ，并且在服务器端创建socket套接字，一直等待客户端发送数据。但是由于客户端并没有发起新的请求，所以会丢弃服务端的SYN 。此时服务器会一直等待客户端发送数据从而造成资源浪费。

       **一、资源浪费观点：引自《计算机网络》释疑与习题解答 谢希仁**

       **如果只有两次握手，当客户端的SYN请求连接在网络管道中阻塞，客户端没有接收到ACK报文，就会重新发送SYN，由于没有第三次握手，服务器不清楚客户端是否收到了自己发送的建立连接的ACK确认信号，所以每收到一个SYN就只能主动建立一个连接，这会造成什么情况呢？如果客户端的SYN阻塞了，重复发送多次SYN报文，那么服务器在收到请求后就会建立多个冗余的无效链接，造成不必要的资源浪费。**
       **即两次握手会造成消息滞留情况下，服务器重复接受无用的连接请求SYN报文，而造成重复分配资源。**

       **二、可靠性论断：**

       **另外一种是 如果想确定双通道通畅，必须使用三个包的发送接收，也就是三次握手：“这个问题的本质是, 信道不可靠, 但是通信双发需要就某个问题达成一致. 而要解决这个问题, 无论你在消息中包含什么信息, 三次通信是理论上的最小值. 所以三次握手不是TCP本身的要求, 而是为了满足"在不可靠信道上可靠地传输信息"这一需求所导致的. 请注意这里的本质需求,信道不可靠, 数据传输要可靠. 三次达到了, 那后面你想接着握手也好, 发数据也好, 跟进行可靠信息传输的需求就没关系了. 因此,如果信道是可靠的, 即无论什么时候发出消息, 对方一定能收到, 或者你不关心是否要保证对方收到你的消息, 那就能像UDP那样直接发送消息就可以了.”**
       **三次是保证双方互相明确对方能收能发的最低值。理论上讲不论握手多少次都不能确认一条信道是“可靠”的，但通过3次握手可以至少确认它是“可用”的，再往上加握手次数不过是提高“它是可用的”这个结论的可信程度。另外Tcp的可靠传输更多的是靠重传机制来保证的**

       **三、初始序列号**

       **三次握手的本质是为了同步双方的初始序列号：**
       **为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤。如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。TCP建立连接的握手，实质上就是建立一个双向的可靠通信连接，一边一个来回，每一边都自带超时重传来确保可靠性(而不是靠握手的次数)。TCP的3次握手是优化的结果，其实它应该是4次握手，由于是从零开始的建立连接，因此将SYN的ACK以及被动打开的SYN合并成了一个SYN-ACK。**
       **握手的作用，旨在确定两个双向的初始序列号，TCP用序列号来编址传输的字节，由于是两个方向的连接，所以需要两个序列号，握手过程不传输任何字节，仅仅确定初始序列号。****

    2. 四次挥手原因

       由于连接的关闭控制权在应用层，所以被动关闭的一方在接收到FIN包时，TCP协议栈会直接发送一个ACK确认包，优先关闭一端的通信。然后通知应用层，由应用层决定什么时候发送FIN包。应用层可以使用系统调用函数read==0来判断对端是否关闭连接。

12. TCP的拥塞控制

    拥塞控制防止过多的数据诸如网络，使得路由器/链路过载。实现的是点对点的通信量控制

    通信双方一开始并不知道网络中的通信状况，需要采用慢开始逐渐改变通信流量，保证每一次的数据都能够顺利发送

    1. 慢开始：发送方的拥塞窗口为1，从小到大逐渐增大发送窗口和拥塞窗口，每一个轮次，拥塞窗口cwnd加倍，当cwnd超过慢开始门限，使用拥塞避免算法，避免cwnd过大

    2. 拥塞避免：到达窗口时，每经过一个RTT，门限上涨1

       在慢开始和拥塞避免的过程中，一旦发现网络拥塞，就把慢开始门限设为当前值的一半，并且重新设置cwnd为1，重新慢启动。（乘法减小，加法增大）

    3. 快重传：收到失序报文就重复确认，三个重复ack触发

    4. 快恢复：快重传发生后，慢开始门限减半，cwnd设置为慢开始门限，采用拥塞避免算法

       使用快恢复算法时，慢开始在建立连接和网络超时时才使用

    采用慢开始和拥塞避免算法的时候

    1. 一旦cwnd>慢开始门限，就采用拥塞避免算法，减慢增长速度

    2. 一旦出现丢包的情况，就重新进行慢开始，减慢增长速度

    采用快恢复和快重传算法的时候

    1. 一旦cwnd>慢开始门限，就采用拥塞避免算法，减慢增长速度

    2. 一旦发送方连续收到了三个重复确认，就采用拥塞避免算法，减慢增长速度

13. TCP的异常断开与心跳机制

    心跳包：服务端用于判断客户端的连接仍然保持--位于应用层的协议，可能只发一些标志位，一定时间内如果没有回复，那么自动断开

    乒乓包：包含简单的数据。包含服务端想要和客户端进行的提醒内容--微信小红点，QQ消息提醒，网易云的点赞

    TCP自带属性：SO_KEETALIVE，自动发送一个存货探测分节（如果2h没有通信，那么发送8个分节（每隔75s一个），同时必须回复）

    ![image-20200810171730425](C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20200810171730425.png)
    
14. TCP是可靠传输，为什么应用层还需要校验

    1. TCP的可靠是针对于传输层而言的，表示的是两个传输层之间进行的是可靠通信

    2. 如果在传输层到应用层的接口出现问题，需要进行校验

    3. 对方由于某个bug，收到这个tcp分节之后来不及处理就异常退出了，那对于发送方的应用层来说，这个消息并不能说发送成功，而对于tcp来说确实是传输可靠的。

       你的程序在某个错误的逻辑下，没有把一个文件分片放进tcp协议栈里，那么对方当然最好得到的是一个破碎的文件。

    4. 判断数据传输过程中是否被恶意篡改
    
15. TCP保证数据传输顺序

    1. 序列号与确认序号保证每一个包都准确发送、接受
    2. 超时重传
    3. 失序确认
    4. 收到已经顺序化的数组。将这些数据按正确的顺序重组成数据流并传递到高层，然后发送累计确认
    
16. socket的拆包和解包

    1. TCP是流协议：没有界限的一串数据，但是需要进行分片
2. 因为是流协议，发送多段数据的时候可能会产生粘包现象，因此需要在发送端封包、接收端拆包
   
    3. UDP是数据包协议，两端数据之间有界限
4. 原因：
       1. Nagle算法：改善网络传输效率，将数据交由TCP发送时，并不立刻发送此段数据，而是等待是否还有数据一同发送
   2. 接收端接受不及时，当应用层没有及时将数据从缓冲区读入时，缓冲区的数据进行了积累
    5. 解决粘包问题
       1. 最简单：两次send之间加入sleep解决，但是大量减少了传输效率
       2. 应答方式：类似于FTP，进行回复确认
       3. 封包和拆包
          1. 给数据加上包头、包含长度和信息
          2. 拆包：
             1. 动态缓冲区暂存方式.之所以说缓冲区是动态的是因为当需要缓冲的数据长度超出缓冲区的长度时会增大缓冲区长度.
             2.  A,为每一个连接动态分配一个缓冲区,同时把此缓冲区和SOCKET关联,常用的是通过结构体关联.
                  B,当接收到数据时首先把此段数据存放在缓冲区中.
                  C,判断缓存区中的数据长度是否够一个包头的长度,如不够,则不进行拆包操作.
                  D,根据包头数据解析出里面代表包体长度的变量.
                  E,判断缓存区中除包头外的数据长度是否够一个包体的长度,如不够,则不进行拆包操作.
                  F,取出整个数据包.这里的"取"的意思是不光从缓冲区中拷贝出数据包,而且要把此数据包从缓存区中删除掉.删除的办法此包后面的数据移动到缓冲区的起始地址.

17. TCP三次握手时出现丢包现象

    1. 第一个SYN包丢失：尝试三次，间隔5.8、24、48s重传三次

    2. 第二个SYN、ACK包丢失：客户端认为没有发送成功，按照1重传

       服务端没有收到第三个ACK认为发送失败，3s、6s、12s重传，可以设置重传次数，如果仍没有收到ACK，关闭连接

    3. 最后一个ACK丢失：

       服务端没有收到ACK进行重传，客户端进入established状态，认为连接建立，发送数据，但是服务端仍是SYN-RCVD状态，有点认为直接关闭进入close（较少)，但是实际中，在客户端ESTABLISHED状态开始发送数据包时，会携带ACK确认序号，所以如果响应ACK丢失了，也能够成功建立连接

    4. 客户端故意不发最后一个ACK，SYN泛洪攻击，此时通过调配重置次数以及等待时间可以解决



### 2. HTTP

1. websocket与http的区别

   1. http1.0的缺陷：通信只能由客户端发起，无法让服务端主动发送信息

      若使用http进行通信，需要经常轮询查询（HTTP2.0改进）

      短链接：每次通信完毕会关闭连接

      http1.1：改进短链接：报文头部增加Connection字段，由用户端发送keep-alive/close来保持/关闭连接，同时可复用连接，同一个连接可以传送多个文件

      ​				增加状态码

      ​				增加host字段，表示同一个IP的主机可以拥有不同的				主机名来保证虚拟主机机制

   2. websocket：双方都可以主动向对端发送信息，全双工协议

   3. ws建立在tcp协议上

      握手阶段使用http协议，端口相同

      数据量格式小

      协议标识符为ws，加密为wss，

   <img src="C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20200721200350112.png" alt="image-20200721200350112" style="zoom: 67%;" />

2. HTTP：基于请求与相应的无状态的应用层协议，常基于tcp/ip协议传输--明文

   通过tcp套接字发送http请求

   <img src="C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20200721205159003.png" alt="image-20200721205159003" style="zoom:67%;" />

3. http报文格式：

   请求报文：请求行、请求头、请求正文

   响应报文：状态行、响应头、响应正文

   ​	1xx:信息已经接受，继续处理

   ​	2xx:成功

   ​	3xx:重定向

   ​	4xx:服务端错误

   ​	5xx:客户端错误

   状态行常见状态码

   - 200 - OK 客户端请求成功
   - 206 - 正确处理部分GET请求
   - 300 - 可选重定向：被请求的资源有一系列可供选择的反馈信息，由浏览器/用户自行选择其中一个
   - 301 - 资源（网页等）被永久转移到其它URL
   - 302 - 临时重定向
   - 304 - not modified :如果客户端发送一个待条件的GET请求并且该请求以经被允许，而文档内容未被改变，则返回304,该响应不包含包体（即可直接使用缓存）。
   - 400 - Bad Request - 客户端请求有语法错误，不能被服务器所理解
   - 401 - Unauthorized - 请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用
   - 403 - 收到请求拒绝提供服务
   - 404 - 请求资源不存在，可能是输入了错误的URL
   - 500 - 服务器内部发生了不可预期的错误l 
   - 503 - Server Unavailable - 服务器当前不能处理客户端的请求，一段时间后可能恢复正常。

4. HTTP2.0：支持多路复用，通过单一链接发送多个请求响应信息，多个流公用TCP链接

5. HTTPS：在http协议上加装了SSL/TLS协议，使用http进行通信。使用加密数据包，提供对网站服务器的身份认证，保护交换数据隐私和完整

   SSL协议：

   **SSL记录协议（SSL Record Protocol）**：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。
   **SSL握手协议（SSL Handshake Protocol）**：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。                                                                             

   **会话层的功能和表示层的功能正好和SSL记录协议和握手协议的功能一样**

   HTTPS就是HTTP加上加密处理（一般是SSL安全通信线路）+认证+完整性保护

   <img src="C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20200721205012345.png" alt="image-20200721205012345" style="zoom:67%;" />

6. HTTPS的优点：

   1. 传输过程可以使用对称密钥加密，安全性更高
   2. HTTPS可以验证用户和服务器，保证数据发送

   HTTPS的缺点：

   1. HTTPS协议在tcp三次握手后需要添加ssl握手（协商加解密密钥），链接起始时间长

   2. https链接缓存不如http高效

   3. 部署成本高：一是需要申请CA证书，二是ssl涉及到的安全算法会增加服务端和客户端的开销

7. HTTP的特点

   1. 无状态：改进使用cookie/session

      cookie：存储一些用户名之类的信息，包含有时间戳保证时效性，存储在客户端，数据以明文保存。Cookie用来保存客户浏览器请求服务器页面的请求信息，我们可以存放非敏感的用户信息，保存时间可以根据需要设置

      session：（单用户的会话状态），sessionID保存在用户本地的cookies之中，保护每个用户的专有信息，生存期是用户持续请求时间加一段时间，存储在服务器内存中，有时效性

      如果含有几千session，需要分目录存放保证效率

   2. HTTP1.0：无连接，每次只处理一个请求

      HTTP1.1：长连接，可以请求某一个部分，增加错误处理，多个请求阻塞处理

      http增加了host表示主机名，表示一个IP地址可以有多个主机
      
      HTTP2.0：增加多路复用，一个连接可以并行处理多个请求
      
      ![image-20200909150930247](C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20200909150930247.png)

### 3. get/post/head

1. get一般用于请求服务器资源，指定的页面信息

   post向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。

2. get：请求行、请求头

   GET url HTTP/1.0

   post：请求行、请求头、请求正文

3. get多用于查询，信息放在url后面使用&进行连接，可以直接通过url获取到

   post多用于提交，信息放在请求报文中，用户无法直接看到

4. get提交数据长度有限制（url限制），具体为浏览器而定

   post长度限定较宽松

5. get只支持ascii码，post可以支持unicode

6. head本质和get相同，但是head不含数据，只返回消息头，可以查询url的相关信息

7. HTTP的请求头包含的信息

   1. get url... HTTP1.0

   2. host:请求web域名服务器的地址，由于HTTP1.0是短链接，没有该头部，HTTP1.1是长连接，可以接受多个发送，用于辨别发送端身份

   3. user-agent：客户端浏览器信息

   4. accept：客户端接受的内容类型

   5. accept-language：返回信息的语言

   6. accept-encoding：编码

   7. content-type：http请求提交的内容类型

   8. connection：是否持久连接

   9. Keep-alive：长连接

   10. cookie

       包含名称、属性值、时间等

   

### 4. 惊群效应

1. 大量线程阻塞到某一临界资源上，之后通过broadcast唤醒，造成系统资源大量被占用，避免的方法使用信号唤醒线程

2. pthread_singal()

   pthread_broadcast()

### 5. OSI七层模型与TCP/IP四层模型

1. TCP/IP四层模型与对应协议

   应用层：http、https、dns、ssh、smtp

   传输层：tcp、udp

   网络层：ip、icmp、igmp

   链路层：arp、rarp、以太网帧协议、mac、vlan

   

   <img src="C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20200723184125094.png" alt="image-20200723184125094" style="zoom: 50%;" />

2. 网络模型的包装 -- 链路层除了链路层封装头部，还有链路层的尾部

   ![image-20200731224350205](C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20200731224350205.png)

   ![image-20200731225433393](C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20200731225433393.png)

3. MAC地址--6字节、IP地址--4字节、端口--2字节

4. 应用层向下是os进行封装

   ![image-20200729215647872](C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20200729215647872.png)

5. 应用层

   HTTP端口80，HTTPS端口443

6. 传输层 -- 端口65536

   ​	TCP数据包格式

   ![image-20200729111114357](C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20200729111114357.png)

   UDP数据包格式

   ![image-20200729111202526](C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20200729111202526.png)

   TCP：16位源端口号、目的端口号

   ​			32位序号、32位确认序号、16位窗口大小

7. 网络层

   <img src="C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20200801135823166.png" alt="image-20200801135823166" style="zoom:80%;" />

   <img src="C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20200731225524858.png" alt="image-20200731225524858" style="zoom:67%;" />

   1. 网络层报文头部信息：

      IPV4、IPV6

      TTL：生存时间，指最大的跳数，防止拥塞网络，没经过一个路由节点，该值减一，减到零时丢弃。最大256

      源、目的IP：4字节

   

8. 数据链路层

   ARP的目的端IP为路由器的下一跳地址

   MAC地址：厂商地址+编号

9. TCP协议：SMTP、TELNET、SSH、FTP

   UDP协议：RIP、TFTP、SNMP

10. 路由器的下一跳获取

    路由表的刷新建立算法：

    1. 静态路由

       手工配置的路由表

    2. 动态路由

       距离向量算法（RIP协议）-- 基于udp（因为需要udp支持，所以在应用层）

       路由器周期性向周围广播自己的路由表，接收到广播后根据上一路由表距离刷新自己的路由表

       链路状态算法（最短路径优先算法）

    3. RIP防止环路

       跳数16表示不可达

       防止环路：触发更新、抑制计时

       ​					水平分割：只能一个端口进一个端口出

       ​					毒性逆转：路径崩溃后长度无限长

11. OSI七层模型

    物理层：通过媒介传输bit，确定机械和电气规范，传输单位为bit，包含IEEE802.3 CLOCK协议

    数据链路层：将bit组装成帧实现点到点的传递，传输单位为帧，包含MAC、VLAN、PPP协议

    网络层：数据包源到宿的网际互连，传输单位为数据包，包含IP，ICMP，IGMP，ARP

    传输层：端到端的可靠报文传递和错误恢复，传输单位为报文，包含TCP、UDP协议

    会话层：建立、管理、终止会话，传输单位为SPDU，包含RPC，NFS协议

    表示层：对数据进行翻译、加密和压缩，传输单位为PPDU，包含JPEG ASII协议

    应用层：允许范围OSI环境，传输单位为APDU，包含FTP，HTTP，DNS

### 6. CS/BS模型

1. CS模型的优缺点：
   1. 缓存大量数据
   2. 协议可以灵活选择
   3. 开发工作量大、调试困难
   4. CS模型权限较大，安全性较低
2. BS模型的优缺点：
   1. 不能缓存大量数据
   2. 协议统一、便捷、安全性较高
   3. 跨平台方便

### 7. Socket网络编程



1. socket--网络套接字

   1. 成对存在，每个套接字对应一个文件描述符fd，对应两个缓冲区，读缓冲区和写缓冲区

      <img src="C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20200723192123070.png" alt="image-20200723192123070" style="zoom:67%;" />

   2. 在客户端、服务器模型中，存在三个文件描述符，其中一个lfd，两个cfd

   3. 与管道的区别
      1. 管道半双工
      2. 管道有两个文件描述符，但是socket一个发送接收端只有一个文件描述符（一个文件描述符指向一个套接字，套接字内部由操作系统安排两个缓冲区）

   4. 网络字节序
      1. 一般的操作系统为小端法存储

      2. 网络字节序为大端法传输

         使用库函数进行转换

2. socket网络编程的链接

   <img src="C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20200723193725455.png" alt="image-20200723193725455" style="zoom:50%;" />

3. 函数详解

   1. socket（）：创建套接字

      IP协议：AF_INET AF_INET6 AF_UNIX

      ​			IP协议：提供无连接不可靠的尽最大努力传输的协议

      type：流式/报式：SOCK_STREAM -- TCP   SOCK_DGRAM -- UDP

      protocol：0

      ![image-20200803134324675](C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20200803134324675.png)

   2. bind（）：绑定套接字到IP+端口

      可以绑定多个ip--仅限多ip主机，只能对自己的ip进行绑定

      1. 首先构造地址信息

         地址信息的构造sockaddr

         通常使用struct sockeaddr_in来表示

         1. AF_INET包含16位地址类型：IPV4/IPV6
         2. 端口，IP地址

         struct sockaddr 结构体变化为很多类型，使用时需要强转指针称为struct sockaddr*类型

         ![image-20200801151331984](C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20200801151331984.png)

      ![image-20200803134511857](C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20200803134511857.png)

   3. listen（）：限制三次握手的监听上限，最大为128

      指定同时允许多少客户端建立连接，同时建立连接的数（指在三次握手过程中的数量）-- 同时发起连接的数量

      ![image-20200803134701460](C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20200803134701460.png)

   4. accept（）：阻塞监听客户端连接

      结束阻塞时，会返回一个新的socket的文件描述符用于通信，该fd成功与客户端建立连接，原始lfd继续进行监听

      ![image-20200803134841090](C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20200803134841090.png)

   5. connect（）：与指定的IP+端口进行连接

      ![image-20200803135136135](C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20200803135136135.png)

      ​	connect（）和bind（）：参数形式一致，但是connect的sockaddr表示的是目的服务器的IP+端口，而bind绑定的是自己的

   6. close（）：关闭文件描述符

   7. read/write：读取socket获取数据

      内核进行

      1. 等待数据准备
      2. 将数据拷贝到进程中

   8. 客户端无需进行bind（），系统会隐式绑定

   9. 滑动窗口就是缓冲区的大小

4. 多进程/多线程并发服务器

   1. 多进程

      while(1)

      {

      ​		cfd  = Accept();

      ​		pid = fork()

      ​		子进程使用时，需要先关闭用于建立的套接字

      ​		父进程：注册信号捕捉函数：SIGCHID，在回调函数中完成子进程回收

      ​		不能用waitpid，因为有多个子进程需要进行回收，此时使用waitpid()，必须用while

      }

   2. 多线程

      cfd = Accept(lfd)

      pthread_create(&tid,NULL,tfn,NULL)

      线程也需要进行回收，但是pthread_join是阻塞回收

      使用pthread_detach(tid)让线程分离

      但是detach不能回收返回值，创建兄弟线程专门进行回收，但是注意兄弟进程，爷孙进程不能相互回收

5. socket如何判断客户端和服务端的匹配问题

   socket在内核注册一副五元组（源IP、源端口、协议号、目的IP、目的端口）

   一副五元组能确定唯一的一条TCP/UDP连接

   监听的socket不含目的端口和源端口，通过accept调用后产生新的socket进行通信

6. 端口复用的设置

   setsockopt

   在bind前对socket进行设置

   level中设置SO_REUSE_ADDR SO_REUSE_PORT

7. 半关闭：通信双方只有一方关闭通信，但是仍然保持连接

8. close（）与shutdown（）

   close表示关闭该文件描述符，如果使用过dup2则无法关闭

   shutdown可以关闭所有经过dup2的文件描述符

   同时可以指定是关闭读端还是写端（不考虑引用计数）

<img src="C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20200723233327858.png" alt="image-20200723233327858" style="zoom: 67%;" />

9. 多线程的fork

   尽管有很多线程栈，但是只复制当前的该线程

   由于其他线程消失，子进程可能发现该资源无法继续使用

   如果继续lock，会导致死锁

10. UDP的CS模型

    不再使用accept，connect

    server:

    ​		socket（）：第二个参数不再使用stream，使用SOCK_DGRAM

    ​		bind（）：无变化，绑定IP和端口号

    ​		listen（）: 可有可无

    ​		while（1）：使用recvfrom而不是read

    ​							  使用sendto而不是write

    ​		close（）

    客户端：

    ​		socket（）

    ​		send_to (客户端地址结构)

    ​		recvfrom

    ​		close（）

    客户端为隐式绑定端口，随机端口发送，使用bind并没有用，只有发送服务器的端口号才有用

11. 多个socket绑定一个端口，只有一个socket会被满足，一个socket绑定多个端口返回错误值

12. server最大TCP链接数

    无限地址空间，但是tcp连接只能建立小于65536个

    2^32个（IP) * 2^16（port），端口复用，socket只取决于客户端的区别

    client最大TCP链接数

    65535

### 8. IO多路复用

不需要借助多线程、多进程就可以实现单线程与多客户端进行通信

修改监听上线：<img src="C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20200724170514691.png" alt="image-20200724170514691" style="zoom:67%;" />

不再由应用程序自己监听客户端请求，而是由内核进行，然后转发给引用

有连接请求的时候，内核通知应用，连接立即建立。让内核监听所有客户端的请求

当内核通知应用进程时，说明数据已经写入缓冲区

基本原理就是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。

当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。

1. Select

   最大文件描述符+1，传入fd的bitmap，传出fd的bitmap，异常事件的bitmap，超时时长

   1. 超时时长：NULL--阻塞、0--非阻塞

   2. 借用内核对select进行转接

   3. 使用FD_ZERO FD_SET FDISSET进行fd的置位查看

   4. select的调用过程

      socket-bind-listen-select

   5. select的优缺点

      1. 只能轮询判断bitmap，只能自己添加业务逻辑
      2. 监听上限1024
      3. 跨平台监听（其他需要libevent）

2. poll

   <img src="C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20200724153418618.png" alt="image-20200724153418618" style="zoom:200%;" />

   fds：监听的文件描述符结构体数组，nfds：有效监听个数，超时时长

   1. 超时时长：-1阻塞 0非阻塞 >0超时时长
   2. 返回值：满足对应监听事件的文件描述符个数
   3. if（pfds[i].revents & POLLIN)
      	accetpt()    /   read()
   4. 优缺点：
      1. 自带数据结构可以判断监听事件
      2. 将监听事件与返回事件结合分离
      3. 拓展监听上线1024
      4. 只能用于linux
      5. 无法直接定位满足监听事件的描述符

3. epoll

   1. 底层数据结构：平衡二叉树（红黑树）

   2. epoll_create(size)：建立size大小的红黑树，返回树根（size为建议值）

   3. epoll_ctl （epfd，op，fd，event）：插入红黑树节点，op操作：EPOLL_CTL_ADD EPOLL_CTL_MOD EPOLL_CTL_DEL

      设置events事件，结构体+嵌套union

   4. epoll_wait（int epfd, struct epoll_event*events ,int maxevents, int timeout)

   ​		events:传出参数，满足监听条件的文件描述符+结构体，不再需要轮询

   ​		max_events:最大的epoll结构体数组

   ​		timeout：-1 阻塞，0非阻塞，>0超时时间ms

   5. 返回值：>0，满足监听的总个数，可以用作循环上限

   <img src="C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20200724171923421.png" alt="image-20200724171923421" style="zoom:50%;" />

   6. epoll调用过程

      lfd = socket（）

      bind（） listen（）

      epoll_create epoll_ctl epoll_wait

   7. 当read==0时，使用epoll_ctl从红黑树上摘下

   8. epoll触发模式，在event.events = EPOLLIN | EPOLLET;  （使用fcntl设置阻塞）

      1. ET：边沿触发：下次传进来会读取上次数据，支持非阻塞socket

         使用et可以减少epoll_wait返回的次数

      2. LT：水平出发：未读完的数据也会触发epoll返回 -- 默认，支持阻塞和非阻塞socket

      3. ![image-20200724194911192](C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20200724194911192.png)

   9. epoll的优缺点：

      1. 避免文件描述符的轮询
      2. 高效编码简单
      3. 可以突破1024个描述符
      4. 速度更快，进程无需将文件描述符调入内核进行监听，内核通过共享内存查看监听fd

   10. epoll反应堆模型

       1. 非阻塞、ET、使用函数代替data中的void*

       2. EPOLL_WAIT等待读，然后修改红黑树，将读节点取下来，修改模式为写，然后EPOLL_WAIT等待写入，然后写完后取下来，修改为读，再挂上去

       3. 使用回调函数时只需要加上本身结构体的指针即可，里面的信息足够函数使用

          

   11. ![image-20200729220633548](C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20200729220633548.png)

       ![image-20200729220644576](C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20200729220644576.png)

   12. 

4. read函数

   ![image-20200724190952419](C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20200724190952419.png)

   

5. 线程池：

   线程池扩容：当线程达到一定的比例（转载因子）

   程序运行初期创建大量线程，然后阻塞到条件变量上

   使用管理线程进行线程池的扩容、缩容

   <img src="C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20200810172513992.png" alt="image-20200810172513992" style="zoom:67%;" />

### 9. 输入url到网页展示的过程

<img src="C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20200724223105034.png" alt="image-20200724223105034" style="zoom:57%;" />

输入url需要找到对应的ip地址：DNS协议

两种查找方式：递归查询、迭代查询

<img src="C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20200724223112683.png" alt="image-20200724223112683" style="zoom:60%;" />

hosts：本地数据库。用于存储常用的域名到ip的映射

1. 使用DNS协议获取域名对应的IP地址
2. 浏览器与服务器建立TCP连接
3. 浏览器发送http请求
4. 服务器回传数据
5. 浏览器开始渲染解析，遇到外部js、css发送http请求
6. 渲染完毕展示

HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。

HTTP 请求/响应的步骤如下：

1、客户端连接到Web服务器

一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，[http://www.baidu.com](http://www.baidu.com/)。

2、发送HTTP请求

通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。

3、服务器接受请求并返回HTTP响应

Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。

4、释放连接TCP连接

若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;

5、客户端浏览器解析HTML内容

客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。

4、举例：

在浏览器地址栏键入URL，按下回车之后会经历以下流程：

1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址；

2、解析出 IP 地址后，根据该 IP 地址和默认端口80，和服务器建立TCP连接；

3、浏览器发出读取文件（URL中域名后面部分对应的文件）的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器；



4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器；

5、释放 TCP连接；

6、浏览器将该 html 文本并显示内容；

### 10. telnet

模拟浏览器对IP+端口进行通信

### 11. 加密传输中的加盐法

原始字符串末尾添加随机字符串然后再加密

### 12. MD5

抗原像（单向性）、抗第二原像、抗碰撞

### 13. SYN泛洪攻击

使用伪造不存在的IP发送请求，让服务端不断回传SYN，ACK

解决方式：SYN不重发，发送RST

也是三次握手的必要性

### 14. TCP/UDP分段

TCP分段在传输层实现，受MSS的影响，每个包都是完整的头部+内容

UDP分段在网络层实现，受MTU的影响，后面的包没有UDP头部？？

### 15. IP的三种地址类型

​	IP地址4字节32位，分为网络地址+主机地址

![image-20200729110243993](C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20200729110243993.png)

​	A类的子网掩码为：255.0.0.0

​	B类的子网掩码为：255.255.0.0

​	C类的子网掩码为：255.255.255.0

### 16. CA证书

1. web服务器的数字证书包含：公钥，公钥拥有者信息，签发者信息，有效期
2. 首先对证书--明文进行检查：是否过期，公钥拥有者url和当前是否相等，然后加密指纹，生成信息摘要，然后对比摘要信息
3. 浏览器内置顶级CA机构的证书，而证书存在信任链，收到c证书，由b颁发，于是取请求b，b证书由a颁发，a内置，所以C有效

### 17. 本地DNS服务器

​	一般是指默认的dns服务器，也可能由dhcp自动分配

​	    本地是一个相对的概念，因为DNS服务是有很多级的，所以更靠近用户的那级服务器就叫做本地DNS服务器。比如114和8.8.8.8这样的DNS服务器处于根服务器之下所以可以算作是本地DNS服务，很多运营商都会在当地架设自己的DNS服务器储存着常用的域名映射，用来为用户提供更快的域名解析服务。

### 18. HTTPS的中间人攻击

1. SSL劫持攻击：SSL证书欺骗攻击，将自己接入客户端和目标之间，但是此时客户端的证书校验会出现错误（IP地址不对）
2. SSL剥离攻击：客户端与中间人进行HTTP会话，与主机进行HTTPS会话

### 19. NAT映射

1. 一般路由器兼有交换机的功能

2. 在路由器中，除了路由表还包含NAT映射表

   路由器拥有公网IP，路由器对应主机为本地私有IP

3. 分类

   1. 静态NAT ：内部私有IP -- 公网IP    一对一不变

   2. 动态NAT：内部私有IP -- 公网IP 私有IP多，为多对多，动态NAT：在路由器上配置外网IP地址池，当需要时，去除外网IP。绑定到NAT表中通信完毕后释放
   3. 网络地址端口转换：使用IP：端口唯一表示一个内网IP  

4. 打洞机制：路由器保护：陌生IP第一次发送数据包自动丢弃

   使用中间公网IP进行打洞操作-- 局域网内不需要打洞机制

   ![image-20200801142451711](C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20200801142451711.png)

### 20. IP地址、MAC地址

IP地址在网络中唯一标识一台主机的逻辑地址，提供的一种统一的地址格式，为网络上每一台主机分配的逻辑地址，用于屏蔽物理地址的差异

端口号：主机中唯一表示一个进程

MAC地址：链路层标识一台设备，用于定义网络设备的位置，为数据链路层负责

### 21. 查看端口进程

netstat -apn | grep xxxx

### 22. 自动建立的文件描述符

0，1，2：标准输入、标准输出、标准错误

### 23. TCP/IP数据链路层

网络层等到链路层用mac地址作为通信目标。数据包达到链路层准备发送时。首先去arp缓存表查看目标ip的mac地址，如果查到就将mac地址封装到链路层数据包的包头，如果没找到，发送广播，所有收到的机器查看ip，然后以单播的形式回传

网络层等到数据链层用mac地址作为通信目标，数据包到达网络等准备往数据链层发送的时候，首先会去自己的arp缓存表(存着ip-mac对应关系)去查找改目标ip的mac地址，如果查到了，就讲目标ip的mac地址封装到链路层数据包的包头。如果缓存中没有找到，会发起一个广播：who is ip XXX tell ip XXX,所有收到的广播的机器看这个ip是不是自己的，如果是自己的，则以单拨的形式将自己的mac地址回复给请求的机器

### 24. server端监听但是没有连接进入

1. 如果没有采用多路复用技术，进程为阻塞状态
2. 其他为运行状态

### 25. epoll的死锁

readn读取数据不够n个，阻塞，但是修改缓冲区需要epoll返回，二者阻塞

修改cfd为非阻塞读

### 26. 阻塞与非阻塞

1. 阻塞与非阻塞

   阻塞和非阻塞：调用者在事件没有发生的时候，一直在等待事件发生，不能去处理别的任务这是阻塞。调用者在事件没有发生的时候，可以去处理别的任务这是非阻塞。

   同步和异步

   同步和异步：调用者必须循环自去查看事件有没有发生，这种情况是同步。调用者不用自己去查看事件有没有发生，而是等待着注册在事件上的回调函数通知自己，这种情况是异步

2. send函数用来向TCP连接的另一端发送数据。客户程序一般用send函数向服务器发送请求，而服务器则通常用send函数来向客户程序发送应答,send的作用是将要发送的数据拷贝到缓冲区，协议负责传输。

   recv函数用来从TCP连接的另一端接收数据，当应用程序调用recv函数时，recv先等待s的发送缓冲中的数据被协议传送完毕，然后从缓冲区中读取接收到的内容给应用层。
   accept函数用了接收一个连接，内核维护了半连接队列和一个已完成连接队列，当队列为空的时候，accept函数阻塞，不为空的时候accept函数从上边取下来一个已完成连接，返回一个文件描述符。

### 27. 非阻塞

1. 阻塞和非阻塞一般指读任务

   设置socket使其变为non-blocking

   read时如果数据没准备好，返回一个error，用户进程等待再次发送read（fcntl())

### 28. 几个IO模型

1. 阻塞IO模型

2. 非阻塞IO模型

3. 异步IO模型

   用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。

4. 信号驱动模型

   首先我们允许套接口进行信号驱动I/O,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。

### 29. 

1. 同步阻塞：

   等待任务完成返回，什么都不做，等待调用返回

2. 异步阻塞

   调用返回前，进程挂起，调用结束时提醒

3. 同步非阻塞

   调用后执行别的，是不是轮询检查

4. 异步非阻塞

   调用后执行别的，等待完毕的通知

5. ![image-20200813154155063](C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20200813154155063.png)

   同步:

   A调用B，B处理直到获得结果，才返回给A。需要调用者一直等待和确认调用结果是否返回， 然后继续往下执行。

   异步:

   A调用B，B直接返回。无需等待结果，B通过状态，通知等来通知A或回调函数来处理。调用结果返回时， 会以消息或回调的方式通知调用者。

   阻塞：

   A调用B，A被挂起直到B返回结果给A，A继续执行。
    调用结果返回前，当前进程挂起不能够处理其他任务，一直等待调用结果返回。

   非阻塞：

   A调用B，A不会被挂起，A可以执行其他操作。
    调用结果返回前，当前进程不挂起， 可以去处理其他任务。

![image-20200813155037943](C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20200813155037943.png)

### 30. TCP传输速率

​	拥塞窗口可以解决传输速率过大导致链路过载导致丢包

​	流量控制：通过滑动窗口来控制传输速率

​	服务器速率：ISP接入服务提供商向客户端开放的接口接入速率

​	慢启动引发的性能问题：

​		海量用户访问后台进行海量小文件传输可能存在慢启动的性能问题，每个文件采用单独的tcp连		接。

		1. 对于小文件来说，使用单独的tcp连接需要慢启动算法，可能需要多个包进行传递，需要大量的seq-ack组合RTT时间。（大量的三次握手、四次挥手的时间）
  		2. 应该将文件公用tcp连接进行传递，这样可以使用较大的拥塞窗口的数据量
                		3. 绑定多cpu的多核到网卡的多个通道，由多核来均分传输小文件，每个核使用tcp连接来发送分配到的小文件

### 31. epoll效率

1. 不再需要轮询查看事件就绪，就绪事件以指针数组形式直接查看

2. 每次调用无需再向内核中传送需要监听的文件描述符，在调用epoll_create时，内存在内核态开始准备监控句柄，每次调用epoll_ctl只是向内核中添加新的socket句柄

3. 在内核中，所有的均为文件，epoll注册文件系统存储监控socket，调用epoll_create时创建一个file节点，只服务于epoll，不是普通文件。epoll在内核初始化时，开辟自己的高速缓冲区cache，用于安置socket。以红黑树的形式存储

4. 除此之外，建立list存储就绪事件，返回时只需要查看list是否有数据即可

5. 当socket有数据到了，内核把网卡上的数据复制到内核中，把socket放入就绪链表

6. **一颗红黑树，一张准备就绪句柄链表，少量的内核cache，就帮我们解决了大并发下的socket处理问题。执行epoll_create时，创建了红黑树和就绪链表，执行epoll_ctl时，如果增加socket句柄，则检查在红黑树中是否存在，存在立即返回，不存在则添加到树干上，然后向内核注册回调函数，用于当中断事件来临时向准备就绪链表中插入数据。执行epoll_wait时立刻返回准备就绪链表里的数据即可。**

   通过epoll_wait()系统调用判断双向链表是否为空，如果为空则阻塞。当文件描述符状态改变，fd上的回调函数被调用，该函数将fd加入到双向链表中，此时epoll_wait函数被唤醒，返回就绪好的事件。 

### 32. 单线程处理高并发

1. 减少阻塞
2. 使用I/O多路复用处理多个请求
3. 采用时间驱动模型，基于异步回调处理事件

### 33. 可变参数模板

 template<typename T>   

 可变参数模板：对参数进行高度泛化，可以表示任意数目，任意类型的参数，再typename和class后面加省略号如下

![image-20200804224808191](C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20200804224808191.png)                     

省略号作用如下：

1）声明一个包含0到任意个模板参数的参数包

2）在模板定义得右边，可以将参数包展成一个个独立的参数

C++11可以使用递归函数的方式展开参数包，获得可变参数的每个值。通过递归函数展开参数包，需要提供一个参数包展开的函数和一个递归终止函数。         

![image-20200804224933920](C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20200804224933920.png)                                                                                                                                  

### 34. tcp粘包现象

1. 发送方原因：Nagle算法：将较小的内容拼接成大的内容发送

2. 接收方原因：TCP接收到分组时，应用层不一定及时处理，如果接受分组的速度大于读取速度，多个包将被保存到缓存，应用程序读时就会读到首位连接到一起的包

   接收方无边界接收，导致边界混淆，数据融合

3. 何时需要处理粘包现象

   1. 如果发送方发送的多个分组是一个数据的不同部分，例如一个大文件分组发送，不需要处理
   2. 如果多个分组互不相干且并列，需要处理粘包问题。

4. 处理粘包现象

   1. 发送方：关闭nagle算法
   2. 接收方：只能在应用层处理

### 35. read/write send/recv

1. read：>0时返回实际独到的大小

   ​			=0代表连接关闭

   ​			<0代表出错，读取设置了的errono即可

   write：成功时返回写的字节数，失败返回-1并设置errorno

2. send/recv：提供第四个参数来控制读写操作

   int recv(int sockfd,void *buf,int len,int flags)
   int send(int sockfd,void *buf,int len,int flags)

   | MSG_DONTROUTE | 不查找表 |          -- 目的主机在本地网络
   | MSG_OOB | 接受或者发送带外数据 |
   | MSG_PEEK | 查看数据,并不从系统缓冲区移走数据 |
   | MSG_WAITALL | 等待所有数据 

   其中waitall的参数如下

   1)当读到了指定的字节时,函数正常返回.返回值等于len 

   2)当读到了文件的结尾时,函数正常返回.返回值小于len 

   3)当操作发生错误时,返回-1,且设置错误为相应的错误号(errno)

   

### 36. TCP半连接/全连接

半连接队列：SYN队列

全连接队列：accept队列

1. 服务端收到syn时，将该连接存到半连接队列，并响应syn+ack

2. 收到客户端的ack后，移出半连接，放入全连接accept队列，然后accept返回（可以防止syn泛洪攻击）

   <img src="C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20200820184934640.png" alt="image-20200820184934640" style="zoom:50%;" />

3. 当半连接队列和全连接队列满时，内核丢弃发送RST包（使用ss指令查看全连接队列情况）

4. 调整全连接队列大小：somaxconn和backlog之间的最小值

   somaxconn：linux内核参数，默认128，可以更改/proc。。。进行修改

   backlog：listen的第二个参数‘

   调整半连接队列大小：使用netstat指令查看SYN_RECV状态的TCP连接

   两个队列之和不超过backlog

### 37. 抓包

使用tcpdumpy可在命令行进行数据包抓取

网卡位于链路层的MAC子层

1. 抓取别的MAC地址的数据：开启网卡混杂模式，抓取任何经过对他的包

2. linux抓包原理：注意一种虚拟的底层网络协议获得对网络报文的处理权。当网卡接收到网络报文时，会遍历所有已经注册的网络协议（以太网协议等）对报文进行解析处理。

   当抓包伪装成一个网络协议的时候，系统收到报文会让伪协议进行一次窥探的机会（处理机会），此时该模块对报文进行窥探，复制一份，假装是自己接收到的，反馈给抓包

3. 一般使用tcpdump获取报文，然后使用wireshark分析

4. TCPdump

   1. host：缺省类型：表明主机
   2. net：表名网络地址
   3. port：端口号
   4. src：IP包来源
   5. dst：目的网络地址
   6. 协议关键字：ip、arp、rarp、tcp、udp

   对于多个可以使用and 、notxx来抓

   ![image-20200823162827531](C:\Users\10232\AppData\Roaming\Typora\typora-user-images\image-20200823162827531.png)

### 38. cookie和session

由于HTTP为无状态协议，无法区分多次请求是否发送自同一客户端，为客户端保存可复用数据

1. cookie

购物车、用户登录在cookie中--但是现在使用token

HTTP请求头、响应头都有cookie方面的数据

服务器发送到浏览器，并保存在浏览器本地中----cookie。他在下次向服务器发送请求时自动携带到服务器上

用于告知两个请求是否来自于同一浏览器

1. 会话状态管理（登陆状态、购物车、分数）

2. 个性化设置

3. 浏览器行为跟踪

   问题：浏览器可以禁用cookie，存在安全隐患（跨站请求伪造）

4. 会话cookie：存放在内存中，关闭浏览器消失

   持久化cookie：存放在磁盘上，过了有效期自动删除

服务器：

1. 向浏览器返回cookie（set cookie请求头），包塑浏览器保存/删除cookie
2. 读取浏览器请求携带的cookie（cookie请求头）

浏览器：

1. 接受cookie，保存/删除
2. 请求时自动携带相应的cookie

2. session

服务端：内存中的特定对象--保存特定的对象

将用户信息存储在内存一个容器中，然后返回sessionid到cookie中

使用cookie保存sessionid的值，便于浏览器直接查找目的session

发送请求时，自动携带cookie，自此自动携带到session

流程：

1. 浏览器访问服务器时，创建session对象，保存特定数据
2. session拥有唯一id，服务器自动用会话cookie（关闭自动销毁）携带sessionid
3. 浏览器受到相应后，自动保存sessionid的cookie，之后会自动携带
4. 服务器收到请求后，根据sessionid自动找到创建session对象

如果想要长时间免登录，设置持久化cookie